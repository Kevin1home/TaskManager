{
  "project_info": {
    "name": "tests",
    "path": "C:\\Users\\kevin\\dev\\TaskManager\\tests",
    "generated_at": "2025-09-14T16:23:16.4285927",
    "total_files": 8,
    "total_size": 96658
  },
  "structure": {
    "com": {
      "taskmanager": {
        "api": {
          "HttpTaskServerTest.java": {
            "type": "file",
            "info": {
              "size": 32673,
              "last_modified": "2025-09-14T16:23:16.3681121",
              "mime_type": "text/x-java-source",
              "extension": ".java"
            }
          }
        },
        "managers": {
          "FileBackedTaskManagerTest.java": {
            "type": "file",
            "info": {
              "size": 6419,
              "last_modified": "2025-09-14T16:23:16.386521",
              "mime_type": "text/x-java-source",
              "extension": ".java"
            }
          },
          "HistoryManagerTest.java": {
            "type": "file",
            "info": {
              "size": 4937,
              "last_modified": "2025-09-14T16:23:16.3935673",
              "mime_type": "text/x-java-source",
              "extension": ".java"
            }
          },
          "HttpTaskManagerTest.java": {
            "type": "file",
            "info": {
              "size": 12465,
              "last_modified": "2025-09-14T16:23:16.3995673",
              "mime_type": "text/x-java-source",
              "extension": ".java"
            }
          },
          "InMemoryHistoryManagerTest.java": {
            "type": "file",
            "info": {
              "size": 332,
              "last_modified": "2025-09-14T16:23:16.4043064",
              "mime_type": "text/x-java-source",
              "extension": ".java"
            }
          },
          "InMemoryTaskManagerTest.java": {
            "type": "file",
            "info": {
              "size": 579,
              "last_modified": "2025-09-14T16:23:16.4085013",
              "mime_type": "text/x-java-source",
              "extension": ".java"
            }
          },
          "TaskManagerTest.java": {
            "type": "file",
            "info": {
              "size": 26002,
              "last_modified": "2025-09-14T16:23:16.4129091",
              "mime_type": "text/x-java-source",
              "extension": ".java"
            }
          }
        },
        "tasks": {
          "EpicTest.java": {
            "type": "file",
            "info": {
              "size": 13251,
              "last_modified": "2025-09-14T16:23:16.4200197",
              "mime_type": "text/x-java-source",
              "extension": ".java"
            }
          }
        }
      }
    }
  },
  "files": [
    {
      "path": "com\\taskmanager\\api\\HttpTaskServerTest.java",
      "content": "package com.taskmanager.api;\r\n\r\nimport com.google.gson.*;\r\nimport com.taskmanager.managers.InMemoryHistoryManager;\r\nimport com.taskmanager.managers.TaskManager;\r\nimport org.junit.jupiter.api.AfterEach;\r\nimport org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\nimport com.taskmanager.tasks.*;\r\n\r\nimport java.io.IOException;\r\nimport java.net.URI;\r\nimport java.net.http.HttpClient;\r\nimport java.net.http.HttpRequest;\r\nimport java.net.http.HttpResponse;\r\nimport java.time.Duration;\r\nimport java.time.LocalDateTime;\r\nimport java.util.logging.Logger;\r\n\r\nimport static com.taskmanager.managers.HttpTaskManager.load;\r\n\r\n/**\r\n * Integration tests for {@link HttpTaskServer}.\r\n * <p>\r\n * This class verifies the REST API of Task Manager:\r\n * <ul>\r\n *   <li>Creating tasks, epics, and subtasks (POST)</li>\r\n *   <li>Retrieving tasks by ID and by type (GET)</li>\r\n *   <li>Updating tasks, epics, and subtasks (PUT)</li>\r\n *   <li>Deleting tasks of all types and by ID (DELETE)</li>\r\n *   <li>Checking prioritized tasks and history endpoints</li>\r\n * </ul>\r\n * <p>\r\n * Servers used:\r\n * <ul>\r\n *   <li>{@link KVServer} – for storing data</li>\r\n *   <li>{@link HttpTaskServer} – for providing HTTP API</li>\r\n * </ul>\r\n * </p>\r\n */\r\nclass HttpTaskServerTest {\r\n\r\n    private KVServer kvServer;\r\n    private HttpTaskServer httpTaskServer;\r\n    private HttpClient httpClient;\r\n    TaskManager taskManager = load(KVServer.PORT);\r\n\r\n    private final Gson gson = new Gson();\r\n    private static final Logger logger = Logger.getLogger(HttpTaskServerTest.class.getName());\r\n\r\n    private String jsonTask;\r\n    private String jsonEpic;\r\n    private String jsonSubtask;\r\n\r\n    @BeforeEach\r\n    void setUp() throws IOException, InterruptedException {\r\n        logger.info(\"Starting KVServer and HttpTaskServer before test...\");\r\n        kvServer = new KVServer();\r\n        kvServer.start();\r\n        httpTaskServer = new HttpTaskServer();\r\n        httpTaskServer.start();\r\n        httpClient = HttpClient.newHttpClient();\r\n\r\n        convertTasksToJson();\r\n\r\n        logger.info(\"Creating test data (Task, Epic, Subtask)...\");\r\n        // creating task\r\n        URI url1 = URI.create(\"http://localhost:8080/tasks/task\");\r\n        HttpRequest.BodyPublisher body1 = HttpRequest.BodyPublishers.ofString(jsonTask);\r\n        HttpRequest request1 = HttpRequest.newBuilder().uri(url1).POST(body1).build();\r\n        httpClient.send(request1, HttpResponse.BodyHandlers.ofString());\r\n        // creating epic\r\n        URI url2 = URI.create(\"http://localhost:8080/tasks/epic\");\r\n        HttpRequest.BodyPublisher body2 = HttpRequest.BodyPublishers.ofString(jsonEpic);\r\n        HttpRequest request2 = HttpRequest.newBuilder().uri(url2).POST(body2).build();\r\n        httpClient.send(request2, HttpResponse.BodyHandlers.ofString());\r\n        // creating subtask\r\n        URI url3 = URI.create(\"http://localhost:8080/tasks/subtask\");\r\n        HttpRequest.BodyPublisher body3 = HttpRequest.BodyPublishers.ofString(jsonSubtask);\r\n        HttpRequest request3 = HttpRequest.newBuilder().uri(url3).POST(body3).build();\r\n        httpClient.send(request3, HttpResponse.BodyHandlers.ofString());\r\n\r\n        logger.info(\"Test data created successfully.\");\r\n    }\r\n\r\n    @AfterEach\r\n    void tearDown() {\r\n        // stopping Servers\r\n        logger.info(\"Stopping KVServer and HttpTaskServer after test...\");\r\n        kvServer.stop();\r\n        httpTaskServer.stop();\r\n        // manual deleting of all changes in Program\r\n        taskManager.deleteAllTasksAllTypes();\r\n        taskManager.setNextId(1);\r\n        taskManager.setHistoryManager(new InMemoryHistoryManager());\r\n\r\n        logger.info(\"Test environment cleaned up.\");\r\n    }\r\n\r\n    private void convertTasksToJson() {\r\n        Task task = new Task(\"Task\", \"DescrT\", TaskStatus.NEW, \"30.06.2024, 09:30\", 60L);\r\n        task.setId(1);\r\n        jsonTask = gson.toJson(task);\r\n\r\n        Epic epic = new Epic(\"Epic1\", \"DescrEp1\");\r\n        epic.setId(2);\r\n        jsonEpic = gson.toJson(epic);\r\n\r\n        Subtask subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, \"01.06.2024, 12:30\", 120L, 2);\r\n        subtask.setId(3);\r\n        jsonSubtask = gson.toJson(subtask);\r\n    }\r\n\r\n    // check endpoint GET\r\n    @Test\r\n    void shouldReturnListOfPrioritizedTasks() throws IOException, InterruptedException {\r\n        // getting prioritized list of tasks\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n        // converting to JsonArray\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonArray jsonArray = jsonElement.getAsJsonArray();\r\n\r\n        int expectedSize = 2; // +1 Task and +1 Subtask (there is no Epics in Prioritized Tasks)\r\n        int actualSize = jsonArray.size();\r\n        String expectedLastTask = jsonTask;\r\n        String actualLastTask = String.valueOf(jsonArray.get(1));\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n        Assertions.assertEquals(expectedLastTask, actualLastTask);\r\n    }\r\n\r\n    // check endpoint GET_HISTORY\r\n    @Test\r\n    void shouldReturnHistory() throws IOException, InterruptedException {\r\n        // adding task to history by method get\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/task?id=1\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n        // adding epic to history by method get\r\n        URI url5 = URI.create(\"http://localhost:8080/tasks/epic?id=2\");\r\n        HttpRequest request5 = HttpRequest.newBuilder().uri(url5).GET().build();\r\n        httpClient.send(request5, HttpResponse.BodyHandlers.ofString());\r\n        // adding subtask to history by method get\r\n        URI url6 = URI.create(\"http://localhost:8080/tasks/subtask?id=3\");\r\n        HttpRequest request6 = HttpRequest.newBuilder().uri(url6).GET().build();\r\n        httpClient.send(request6, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // getting history\r\n        URI url7 = URI.create(\"http://localhost:8080/tasks/history\");\r\n        HttpRequest request7 = HttpRequest.newBuilder().uri(url7).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request7, HttpResponse.BodyHandlers.ofString());\r\n        // converting to JsonArray\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonArray jsonArray = jsonElement.getAsJsonArray();\r\n\r\n        int expectedSize = 3; // History: 1, 2, 3\r\n        int actualSize = jsonArray.size();\r\n        String expectedLastTask = jsonSubtask;\r\n        String actualLastTask = String.valueOf(jsonArray.get(2));\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n        Assertions.assertEquals(expectedLastTask, actualLastTask);\r\n    }\r\n\r\n    // check endpoint GET_TASK\r\n    @Test\r\n    void shouldReturnListOfTasks() throws IOException, InterruptedException {\r\n        // getting tasks\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/task\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject().get(\"1\").getAsJsonObject();\r\n\r\n        String expectedTask = jsonTask;\r\n        String actualTask = jsonObject.toString();\r\n\r\n        Assertions.assertEquals(expectedTask, actualTask);\r\n    }\r\n\r\n    // check endpoint GET_EPIC\r\n    @Test\r\n    void shouldReturnListOfEpics() throws IOException, InterruptedException {\r\n        // getting epics\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/epic\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject().get(\"2\").getAsJsonObject();\r\n\r\n        // rewriting Epic cause of the lack of data by preparing in setUp\r\n        Epic epic = new Epic(\"Epic1\", \"DescrEp1\");\r\n        epic.setId(2);\r\n        Subtask subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, \"01.06.2024, 12:30\", 120L, 2);\r\n        subtask.setId(3);\r\n        epic.subtasks.add(subtask);\r\n        epic.checkDataTimeDurationEpic();\r\n        jsonEpic = gson.toJson(epic);\r\n\r\n        String expectedEpic = jsonEpic;\r\n        String actualEpic = jsonObject.toString();\r\n\r\n        Assertions.assertEquals(expectedEpic, actualEpic);\r\n    }\r\n\r\n    // check endpoint GET_SUBTASK\r\n    @Test\r\n    void shouldReturnListOfSubtasks() throws IOException, InterruptedException {\r\n        // getting subtasks\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/subtask\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject().get(\"3\").getAsJsonObject();\r\n\r\n        String  expectedSubtask = jsonSubtask;\r\n        String actualSubtask = jsonObject.toString();\r\n\r\n        Assertions.assertEquals(expectedSubtask, actualSubtask);\r\n    }\r\n\r\n    // check endpoint GET_SUBTASK_EPIC_ID\r\n    @Test\r\n    void shouldReturnSubtasksOfEpic() throws IOException, InterruptedException {\r\n        // getting epic\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/subtask/epic?id=2\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonArray\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonArray jsonArray = jsonElement.getAsJsonArray();\r\n\r\n        int expectedSize = 1;\r\n        int actualSize = jsonArray.size();\r\n        String expectedSubtask = jsonSubtask;\r\n        String actualLastSubtask = String.valueOf(jsonArray.get(0));\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n        Assertions.assertEquals(expectedSubtask, actualLastSubtask);\r\n    }\r\n\r\n    // check endpoint GET_TASK_ID\r\n    @Test\r\n    void shouldReturnTaskById() throws IOException, InterruptedException {\r\n        // getting task\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/task?id=1\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        String  expectedTask = jsonTask;\r\n        String actualTask = jsonObject.toString();\r\n\r\n        Assertions.assertEquals(expectedTask, actualTask);\r\n    }\r\n\r\n    // check endpoint GET_EPIC_ID\r\n    @Test\r\n    void shouldReturnEpicById() throws IOException, InterruptedException {\r\n        // getting epic\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/epic?id=2\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        // rewriting Epic cause of the lack of data by preparing in setUp\r\n        Epic epic = new Epic(\"Epic1\", \"DescrEp1\");\r\n        epic.setId(2);\r\n        Subtask subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, \"01.06.2024, 12:30\", 120L, 2);\r\n        subtask.setId(3);\r\n        epic.subtasks.add(subtask);\r\n        epic.checkDataTimeDurationEpic();\r\n        jsonEpic = gson.toJson(epic);\r\n\r\n        String expectedEpic = jsonEpic;\r\n        String actualEpic = jsonObject.toString();\r\n\r\n        Assertions.assertEquals(expectedEpic, actualEpic);\r\n    }\r\n\r\n    // check endpoint GET_SUBTASK_ID\r\n    @Test\r\n    void shouldReturnSubtaskById() throws IOException, InterruptedException {\r\n        // getting subtask\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/subtask?id=3\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        String  expectedSubtask = jsonSubtask;\r\n        String actualSubtask = jsonObject.toString();\r\n\r\n        Assertions.assertEquals(expectedSubtask, actualSubtask);\r\n    }\r\n\r\n    // check endpoint POST_TASK\r\n    @Test\r\n    void shouldCorrectlySaveAllFieldsOfTask() throws IOException, InterruptedException {\r\n        // getting task\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/task?id=1\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        String expectedName = gson.fromJson(jsonTask, Task.class).getName();\r\n        String actualName = gson.fromJson(jsonObject.toString(), Task.class).getName();\r\n\r\n        String expectedDescription = gson.fromJson(jsonTask, Task.class).getDescription();\r\n        String actualDescription = gson.fromJson(jsonObject.toString(), Task.class).getDescription();\r\n\r\n        int expectedId = gson.fromJson(jsonTask, Task.class).getId();\r\n        int actualId = gson.fromJson(jsonObject.toString(), Task.class).getId();\r\n\r\n        TaskStatus expectedTaskStatus = gson.fromJson(jsonTask, Task.class).getStatus();\r\n        TaskStatus actualTaskStatus = gson.fromJson(jsonObject.toString(), Task.class).getStatus();\r\n\r\n        String expectedType = gson.fromJson(jsonTask, Task.class).getType();\r\n        String actualType = gson.fromJson(jsonObject.toString(), Task.class).getType();\r\n\r\n        LocalDateTime expectedStartTime = gson.fromJson(jsonTask, Task.class).getStartTime().get();\r\n        LocalDateTime actualStartTime = gson.fromJson(jsonObject.toString(), Task.class).getStartTime().get();\r\n\r\n        Duration expectedDuration = gson.fromJson(jsonTask, Task.class).getDuration().get();\r\n        Duration actualDuration = gson.fromJson(jsonObject.toString(), Task.class).getDuration().get();\r\n\r\n        Assertions.assertEquals(expectedName, actualName);\r\n        Assertions.assertEquals(expectedDescription, actualDescription);\r\n        Assertions.assertEquals(expectedId, actualId);\r\n        Assertions.assertEquals(expectedTaskStatus, actualTaskStatus);\r\n        Assertions.assertEquals(expectedType, actualType);\r\n        Assertions.assertEquals(expectedStartTime, actualStartTime);\r\n        Assertions.assertEquals(expectedDuration, actualDuration);\r\n    }\r\n\r\n    // check endpoint POST_EPIC\r\n    @Test\r\n    void shouldCorrectlySaveAllFieldsOfEpic() throws IOException, InterruptedException {\r\n        // getting epic\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/epic?id=2\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        // rewriting Epic cause of the lack of data by preparing in setUp\r\n        Epic epic = new Epic(\"Epic1\", \"DescrEp1\");\r\n        epic.setId(2);\r\n        Subtask subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, \"01.06.2024, 12:30\", 120L, 2);\r\n        subtask.setId(3);\r\n        epic.subtasks.add(subtask);\r\n        epic.checkDataTimeDurationEpic();\r\n        jsonEpic = gson.toJson(epic);\r\n\r\n        String expectedName = gson.fromJson(jsonEpic, Epic.class).getName();\r\n        String actualName = gson.fromJson(jsonObject.toString(), Epic.class).getName();\r\n\r\n        String expectedDescription = gson.fromJson(jsonEpic, Epic.class).getDescription();\r\n        String actualDescription = gson.fromJson(jsonObject.toString(), Epic.class).getDescription();\r\n\r\n        int expectedId = gson.fromJson(jsonEpic, Epic.class).getId();\r\n        int actualId = gson.fromJson(jsonObject.toString(), Epic.class).getId();\r\n\r\n        TaskStatus expectedTaskStatus = gson.fromJson(jsonEpic, Epic.class).getStatus();\r\n        TaskStatus actualTaskStatus = gson.fromJson(jsonObject.toString(), Epic.class).getStatus();\r\n\r\n        String expectedType = gson.fromJson(jsonEpic, Epic.class).getType();\r\n        String actualType = gson.fromJson(jsonObject.toString(), Epic.class).getType();\r\n\r\n        LocalDateTime expectedStartTime = gson.fromJson(jsonEpic, Epic.class).getStartTime().get();\r\n        LocalDateTime actualStartTime = gson.fromJson(jsonObject.toString(), Epic.class).getStartTime().get();\r\n\r\n        Duration expectedDuration = gson.fromJson(jsonEpic, Epic.class).getDuration().get();\r\n        Duration actualDuration = gson.fromJson(jsonObject.toString(), Epic.class).getDuration().get();\r\n\r\n        Assertions.assertEquals(expectedName, actualName);\r\n        Assertions.assertEquals(expectedDescription, actualDescription);\r\n        Assertions.assertEquals(expectedId, actualId);\r\n        Assertions.assertEquals(expectedTaskStatus, actualTaskStatus);\r\n        Assertions.assertEquals(expectedType, actualType);\r\n        Assertions.assertEquals(expectedStartTime, actualStartTime);\r\n        Assertions.assertEquals(expectedDuration, actualDuration);\r\n    }\r\n\r\n    // check endpoint POST_SUBTASK\r\n    @Test\r\n    void shouldCorrectlySaveAllFieldsOfSubtask() throws IOException, InterruptedException {\r\n        // getting subtask\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/subtask?id=3\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        String expectedName = gson.fromJson(jsonSubtask, Subtask.class).getName();\r\n        String actualName = gson.fromJson(jsonObject.toString(), Subtask.class).getName();\r\n\r\n        String expectedDescription = gson.fromJson(jsonSubtask, Subtask.class).getDescription();\r\n        String actualDescription = gson.fromJson(jsonObject.toString(), Subtask.class).getDescription();\r\n\r\n        int expectedId = gson.fromJson(jsonSubtask, Subtask.class).getId();\r\n        int actualId = gson.fromJson(jsonObject.toString(), Subtask.class).getId();\r\n\r\n        TaskStatus expectedTaskStatus = gson.fromJson(jsonSubtask, Subtask.class).getStatus();\r\n        TaskStatus actualTaskStatus = gson.fromJson(jsonObject.toString(), Subtask.class).getStatus();\r\n\r\n        String expectedType = gson.fromJson(jsonSubtask, Subtask.class).getType();\r\n        String actualType = gson.fromJson(jsonObject.toString(), Subtask.class).getType();\r\n\r\n        LocalDateTime expectedStartTime = gson.fromJson(jsonSubtask, Subtask.class).getStartTime().get();\r\n        LocalDateTime actualStartTime = gson.fromJson(jsonObject.toString(), Subtask.class).getStartTime().get();\r\n\r\n        Duration expectedDuration = gson.fromJson(jsonSubtask, Subtask.class).getDuration().get();\r\n        Duration actualDuration = gson.fromJson(jsonObject.toString(), Subtask.class).getDuration().get();\r\n\r\n        Assertions.assertEquals(expectedName, actualName);\r\n        Assertions.assertEquals(expectedDescription, actualDescription);\r\n        Assertions.assertEquals(expectedId, actualId);\r\n        Assertions.assertEquals(expectedTaskStatus, actualTaskStatus);\r\n        Assertions.assertEquals(expectedType, actualType);\r\n        Assertions.assertEquals(expectedStartTime, actualStartTime);\r\n        Assertions.assertEquals(expectedDuration, actualDuration);\r\n    }\r\n\r\n    // check endpoint PUT_TASK_ID\r\n    @Test\r\n    void shouldUpdateTask() throws IOException, InterruptedException {\r\n        // updating already created task\r\n        Task updateForTask = new Task(\"TaskNew\", \"DescrTNew\", TaskStatus.IN_PROGRESS, \"15.10.2024, 10:40\", 170L);\r\n        String jsonUpdateForTask = gson.toJson(updateForTask);\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/task?id=1\");\r\n        HttpRequest.BodyPublisher body4 = HttpRequest.BodyPublishers.ofString(jsonUpdateForTask);\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).PUT(body4).build();\r\n        httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // getting updated Task\r\n        URI url5 = URI.create(\"http://localhost:8080/tasks/task?id=1\");\r\n        HttpRequest request5 = HttpRequest.newBuilder().uri(url5).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request5, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        // rewriting Task cause of the lack of id info by preparing updateForTask\r\n        updateForTask.setId(1);\r\n        jsonUpdateForTask = gson.toJson(updateForTask);\r\n\r\n        String expectedTask = jsonUpdateForTask;\r\n        String actualTask = jsonObject.toString();\r\n\r\n        Assertions.assertEquals(expectedTask, actualTask);\r\n    }\r\n\r\n    // check endpoint PUT_EPIC_ID\r\n    @Test\r\n    void shouldUpdateEpic() throws IOException, InterruptedException {\r\n        // updating already created epic\r\n        Epic updateForEpic = new Epic(\"EpicNew\", \"DescrTNew\");\r\n        String jsonUpdateForEpic = gson.toJson(updateForEpic);\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/epic?id=2\");\r\n        HttpRequest.BodyPublisher body4 = HttpRequest.BodyPublishers.ofString(jsonUpdateForEpic);\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).PUT(body4).build();\r\n        httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // getting updated Epic\r\n        URI url5 = URI.create(\"http://localhost:8080/tasks/epic?id=2\");\r\n        HttpRequest request5 = HttpRequest.newBuilder().uri(url5).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request5, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        // rewriting Epic cause of the lack of data by preparing updateForEpic\r\n        updateForEpic.setId(2);\r\n        Subtask subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, \"01.06.2024, 12:30\", 120L, 2);\r\n        subtask.setId(3);\r\n        updateForEpic.subtasks.add(subtask);\r\n        updateForEpic.checkDataTimeDurationEpic();\r\n        jsonUpdateForEpic = gson.toJson(updateForEpic);\r\n\r\n        String expectedEpic = jsonUpdateForEpic;\r\n        String actualEpic = jsonObject.toString();\r\n\r\n        Assertions.assertEquals(expectedEpic, actualEpic);\r\n    }\r\n\r\n    // check endpoint PUT_SUBTASK_ID\r\n    @Test\r\n    void shouldUpdateSubtask() throws IOException, InterruptedException {\r\n        // updating already created subtask\r\n        Subtask updateForSubtask = new Subtask(\"SubtaskNew\", \"DescrTNew\", TaskStatus.IN_PROGRESS, \"15.10.2024, 10:40\",\r\n                170L, 2);\r\n        String jsonUpdateForSubtask = gson.toJson(updateForSubtask);\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/subtask?id=3\");\r\n        HttpRequest.BodyPublisher body4 = HttpRequest.BodyPublishers.ofString(jsonUpdateForSubtask);\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).PUT(body4).build();\r\n        httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // getting updated Subtask\r\n        URI url5 = URI.create(\"http://localhost:8080/tasks/subtask?id=3\");\r\n        HttpRequest request5 = HttpRequest.newBuilder().uri(url5).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request5, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        // rewriting Subtask cause of the lack of id info by preparing updateForSubtask\r\n        updateForSubtask.setId(3);\r\n        jsonUpdateForSubtask = gson.toJson(updateForSubtask);\r\n\r\n        String expectedSubtask = jsonUpdateForSubtask;\r\n        String actualSubtask = jsonObject.toString();\r\n\r\n        Assertions.assertEquals(expectedSubtask, actualSubtask);\r\n    }\r\n\r\n    // check endpoint DELETE\r\n    @Test\r\n    void shouldDeleteAllTasksAllTypes() throws IOException, InterruptedException {\r\n        // deleting created Task, Epic and Subtask in 1 request\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).DELETE().build();\r\n        httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // getting list of tasks\r\n        URI url5 = URI.create(\"http://localhost:8080/tasks/\");\r\n        HttpRequest request5 = HttpRequest.newBuilder().uri(url5).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request5, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonArray\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonArray jsonArray = jsonElement.getAsJsonArray();\r\n\r\n        int expectedSize = 0;\r\n        int actualSize = jsonArray.size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    // check endpoint DELETE_TASK\r\n    @Test\r\n    void shouldDeleteAllUsualTasks() throws IOException, InterruptedException {\r\n        // deleting created Task in 1 request\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/task\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).DELETE().build();\r\n        httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // getting tasks\r\n        URI url5 = URI.create(\"http://localhost:8080/tasks/task\");\r\n        HttpRequest request5 = HttpRequest.newBuilder().uri(url5).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request5, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        boolean isEmpty = (jsonObject.get(\"0\") == null);\r\n\r\n        Assertions.assertTrue(isEmpty);\r\n    }\r\n\r\n    // check endpoint DELETE_EPIC\r\n    @Test\r\n    void shouldDeleteAllEpics() throws IOException, InterruptedException {\r\n        // deleting created Epic in 1 request\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/epic\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).DELETE().build();\r\n        httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // getting epics\r\n        URI url5 = URI.create(\"http://localhost:8080/tasks/epic\");\r\n        HttpRequest request5 = HttpRequest.newBuilder().uri(url5).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request5, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        boolean isEmpty = (jsonObject.get(\"0\") == null);\r\n\r\n        Assertions.assertTrue(isEmpty);\r\n    }\r\n\r\n    // check endpoint DELETE_SUBTASK\r\n    @Test\r\n    void shouldDeleteAllSubtasks() throws IOException, InterruptedException {\r\n        // deleting created Subtask in 1 request\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/subtask\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).DELETE().build();\r\n        httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // getting subtasks\r\n        URI url5 = URI.create(\"http://localhost:8080/tasks/subtask\");\r\n        HttpRequest request5 = HttpRequest.newBuilder().uri(url5).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request5, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        boolean isEmpty = (jsonObject.get(\"0\") == null);\r\n\r\n        Assertions.assertTrue(isEmpty);\r\n    }\r\n\r\n    // check endpoint DELETE_TASK_ID\r\n    @Test\r\n    void shouldDeleteChosenUsualTask() throws IOException, InterruptedException {\r\n        // deleting created Task\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/task?id=1\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).DELETE().build();\r\n        httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // getting tasks\r\n        URI url5 = URI.create(\"http://localhost:8080/tasks/task\");\r\n        HttpRequest request5 = HttpRequest.newBuilder().uri(url5).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request5, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        boolean isEmpty = (jsonObject.get(\"0\") == null);\r\n\r\n        Assertions.assertTrue(isEmpty);\r\n    }\r\n\r\n    // check endpoint DELETE_EPIC_ID\r\n    @Test\r\n    void shouldDeleteChosenEpic() throws IOException, InterruptedException {\r\n        // deleting created Epic\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/epic?id=2\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).DELETE().build();\r\n        httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // getting epics\r\n        URI url5 = URI.create(\"http://localhost:8080/tasks/epic\");\r\n        HttpRequest request5 = HttpRequest.newBuilder().uri(url5).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request5, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        boolean isEmpty = (jsonObject.get(\"0\") == null);\r\n\r\n        Assertions.assertTrue(isEmpty);\r\n    }\r\n\r\n    // check endpoint DELETE_SUBTASK_ID\r\n    @Test\r\n    void shouldDeleteChosenSubtask() throws IOException, InterruptedException {\r\n        // deleting created Subtask\r\n        URI url4 = URI.create(\"http://localhost:8080/tasks/subtask?id=3\");\r\n        HttpRequest request4 = HttpRequest.newBuilder().uri(url4).DELETE().build();\r\n        httpClient.send(request4, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // getting subtasks\r\n        URI url5 = URI.create(\"http://localhost:8080/tasks/subtask\");\r\n        HttpRequest request5 = HttpRequest.newBuilder().uri(url5).GET().build();\r\n        HttpResponse<String> response = httpClient.send(request5, HttpResponse.BodyHandlers.ofString());\r\n\r\n        // converting to JsonObject\r\n        JsonElement jsonElement = JsonParser.parseString(response.body());\r\n        JsonObject jsonObject = jsonElement.getAsJsonObject();\r\n\r\n        boolean isEmpty = (jsonObject.get(\"0\") == null);\r\n\r\n        Assertions.assertTrue(isEmpty);\r\n    }\r\n}\r\n",
      "info": {
        "size": 32673,
        "last_modified": "2025-09-14T16:23:16.3681121",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "com\\taskmanager\\managers\\FileBackedTaskManagerTest.java",
      "content": "package com.taskmanager.managers;\r\n\r\nimport org.junit.jupiter.api.*;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\nimport java.util.List;\r\n\r\nimport com.taskmanager.tasks.*;\r\n\r\nimport static java.nio.file.Files.readAllLines;\r\nimport static com.taskmanager.managers.FileBackedTaskManager.loadFromFile;\r\n\r\n/**\r\n * Integration tests for {@link FileBackedTaskManager}.\r\n * <p>\r\n * This class verifies the persistence mechanism of tasks, epics, and subtasks:\r\n * <ul>\r\n *   <li>Saving tasks to a CSV file including history</li>\r\n *   <li>Loading tasks from a CSV file</li>\r\n *   <li>Handling empty files and files without tasks or history</li>\r\n * </ul>\r\n * <p>\r\n * Temporary test files are created and deleted for each test to ensure isolation.\r\n * </p>\r\n */\r\nclass FileBackedTaskManagerTest extends TaskManagerTest<FileBackedTaskManager> {\r\n\r\n    Path pathTest = Paths.get(\"resources\\\\SavesTest.csv\");\r\n\r\n    @BeforeEach\r\n    protected void beforeEach() throws IOException {\r\n        Files.createFile(pathTest);\r\n        taskManager = loadFromFile(pathTest);\r\n        initTasks();\r\n    }\r\n\r\n    @AfterEach\r\n    protected void afterEach() throws IOException {\r\n        taskManager.deleteAllTasksAllTypes();\r\n        taskManager.setNextId(1);\r\n        taskManager.setHistoryManager(new InMemoryHistoryManager());\r\n        Files.delete(pathTest);\r\n    }\r\n\r\n    @Test\r\n    void shouldReturn6LinesQntAfterSaving3TasksWithHistory() throws IOException { // checking method save()\r\n        taskManager.createTask(task);\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        taskManager.getUsualTaskById(task.getId());\r\n        taskManager.getEpicById(epic.getId());\r\n        taskManager.getSubtaskById(subtask.getId());\r\n\r\n        List<String> allLines = readAllLines(pathTest);\r\n\r\n        int expectedLinesQnt = 6; // parameters, Tasks (+3), EmptyLine, history\r\n        int actualLinesQnt = allLines.size();\r\n\r\n        Assertions.assertEquals(expectedLinesQnt, actualLinesQnt);\r\n    }\r\n\r\n    @Test\r\n    void shouldReturn6LinesQntAfterSaving3TasksWithoutHistory() throws IOException { // checking method save()\r\n        taskManager.createTask(task);\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        List<String> allLines = readAllLines(pathTest);\r\n\r\n        int expectedLinesQnt = 6; // parameters, Tasks (+3), EmptyLine, History(Empty)\r\n        int actualLinesQnt = allLines.size();\r\n\r\n        Assertions.assertEquals(expectedLinesQnt, actualLinesQnt);\r\n    }\r\n\r\n\r\n    @Test\r\n    void shouldReturn0LinesQntAfterSaving0TasksWithoutHistory() throws IOException { // checking method save()\r\n        List<String> allLines = readAllLines(pathTest);\r\n\r\n        int expectedLinesQnt = 0; // new file\r\n        int actualLinesQnt = allLines.size();\r\n\r\n        Assertions.assertEquals(expectedLinesQnt, actualLinesQnt);\r\n    }\r\n\r\n    @Test\r\n    void shouldReturn4LinesQntAfterSaving1EpicWithHistory() throws IOException { // checking method save()\r\n        taskManager.createEpic(epic);\r\n        taskManager.getEpicById(epic.getId());\r\n        List<String> allLines = readAllLines(pathTest);\r\n\r\n        int expectedLinesQnt = 4; // parameters, Epic without Subtasks, EmptyLine, history\r\n        int actualLinesQnt = allLines.size();\r\n\r\n        Assertions.assertEquals(expectedLinesQnt, actualLinesQnt);\r\n    }\r\n\r\n    @Test\r\n    void shouldLoad3TasksWithHistoryAfterLoadingFromSavedFile() { // checking method loadFromFile()\r\n        // saving new data\r\n        taskManager.createTask(task);\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        taskManager.getUsualTaskById(task.getId());\r\n        taskManager.getEpicById(epic.getId());\r\n        taskManager.getSubtaskById(subtask.getId());\r\n\r\n        // deleting data direct from System without saving\r\n        InMemoryTaskManager.tasks.clear();\r\n        InMemoryTaskManager.epics.clear();\r\n        InMemoryTaskManager.subtasks.clear();\r\n        InMemoryTaskManager.historyManager = new InMemoryHistoryManager();\r\n\r\n        // loading saved data from file\r\n        loadFromFile(pathTest);\r\n\r\n        boolean isNotEmpty = !taskManager.getTasks().isEmpty() && !taskManager.getEpics().isEmpty()\r\n                && !taskManager.getSubtasks().isEmpty() && !taskManager.getHistoryManager().getHistory().isEmpty();\r\n\r\n        Assertions.assertTrue(isNotEmpty);\r\n    }\r\n\r\n    @Test\r\n    void shouldLoadFromNewEmptyFile() { // checking method loadFromFile()\r\n\r\n        loadFromFile(pathTest); // loading from new empty file\r\n\r\n        boolean isEmpty = taskManager.getTasks().isEmpty() && taskManager.getEpics().isEmpty()\r\n                && taskManager.getSubtasks().isEmpty() && taskManager.getHistoryManager().getHistory().isEmpty();\r\n\r\n        Assertions.assertTrue(isEmpty);\r\n    }\r\n\r\n    @Test\r\n    void shouldLoadFromUsedFileWithoutTasksAndHistory() { // checking method loadFromFile()\r\n        // saving new data\r\n        taskManager.createTask(task);\r\n        taskManager.getUsualTaskById(task.getId());\r\n\r\n        // deleting data with saving\r\n        taskManager.deleteTaskById(task.getId());\r\n\r\n        // loading from used file without tasks and history\r\n        loadFromFile(pathTest);\r\n\r\n        boolean isEmpty = taskManager.getTasks().isEmpty() && taskManager.getEpics().isEmpty()\r\n                && taskManager.getSubtasks().isEmpty() && taskManager.getHistoryManager().getHistory().isEmpty();\r\n\r\n        Assertions.assertTrue(isEmpty);\r\n    }\r\n\r\n    @Test\r\n    void shouldLoadFromSavedFileWithTaskAndWithoutHistory() { // checking method loadFromFile()\r\n        // saving new data\r\n        taskManager.createTask(task);\r\n\r\n        // loading from used file with task and without history file\r\n        loadFromFile(pathTest);\r\n\r\n        boolean isEmptyAllAndTasksNot = !taskManager.getTasks().isEmpty() && taskManager.getEpics().isEmpty()\r\n                && taskManager.getSubtasks().isEmpty() && taskManager.getHistoryManager().getHistory().isEmpty();\r\n\r\n        Assertions.assertTrue(isEmptyAllAndTasksNot);\r\n    }\r\n}",
      "info": {
        "size": 6419,
        "last_modified": "2025-09-14T16:23:16.386521",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "com\\taskmanager\\managers\\HistoryManagerTest.java",
      "content": "package com.taskmanager.managers;\r\n\r\nimport org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport com.taskmanager.tasks.Epic;\r\nimport com.taskmanager.tasks.Subtask;\r\nimport com.taskmanager.tasks.Task;\r\nimport com.taskmanager.tasks.TaskStatus;\r\n\r\n/**\r\n * Abstract tests for implementations of {@link HistoryManager}.\r\n * <p>\r\n * This class verifies the history management functionality, including:\r\n * <ul>\r\n *     <li>Adding tasks, epics, and subtasks to history</li>\r\n *     <li>Preventing duplicates in history</li>\r\n *     <li>Removing tasks by ID from different positions in history</li>\r\n *     <li>Handling empty history correctly</li>\r\n * </ul>\r\n * <p>\r\n * Concrete subclasses should provide a specific {@code HistoryManager} implementation.\r\n * </p>\r\n */\r\nabstract class HistoryManagerTest<T extends HistoryManager> {\r\n\r\n    T historyManager;\r\n    Task task1;\r\n    Task task2;\r\n    Epic epic;\r\n    Subtask subtask;\r\n\r\n    protected void initTasks() {\r\n        task1 = new Task(\"Task\", \"DescrT\", TaskStatus.NEW);\r\n        task1.setId(1);\r\n        task2 = new Task(\"Task\", \"DescrT\", TaskStatus.NEW);\r\n        task2.setId(2);\r\n        epic = new Epic(\"Epic1\", \"DescrEp1\");\r\n        task2.setId(3);\r\n        // For creating tests: subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        // For creating tests: subtask.setId(4);\r\n    }\r\n\r\n    @Test\r\n    void shouldAddNewIdsToHistory() { // checking method add(Task task)\r\n        historyManager.add(task1);\r\n        historyManager.add(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        subtask.setId(4);\r\n        historyManager.add(subtask);\r\n\r\n        int expectedSize = 3;\r\n        int actualSize = historyManager.getHistory().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    void shouldReturnOnly1IdIfDuplicates() { // checking method add(Task task)\r\n        historyManager.add(task1); // +1\r\n        historyManager.add(epic); // +1\r\n        historyManager.add(task1); // +0\r\n\r\n        int expectedSize = 2;\r\n        int actualSize = historyManager.getHistory().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    void shouldReturnHistoryWith2Tasks() { // checking method getHistory()\r\n        historyManager.add(task1);\r\n\r\n        int expectedSize = 1;\r\n        int actualSize = historyManager.getHistory().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    void shouldReturnEmptyHistory() { // checking method getHistory()\r\n\r\n        int expectedSize = 0;\r\n        int actualSize = historyManager.getHistory().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    void shouldReturn1IdInHistoryAfterAdding2AndRemove1() { // checking method remove(int id)\r\n        historyManager.add(task1); // +1\r\n        historyManager.add(task2); // +1\r\n        historyManager.remove(task1.getId()); // -1\r\n\r\n        int expectedSize = 1;\r\n        int actualSize = historyManager.getHistory().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    void shouldRemoveIdFromMiddleOfHistory() { // checking method remove(int id)\r\n        historyManager.add(task1); // +1\r\n        historyManager.add(epic); // +1\r\n        historyManager.add(task2); // +1\r\n        historyManager.remove(epic.getId()); // -1\r\n\r\n        boolean isTrue = historyManager.getHistory().get(0).equals(task1)\r\n                && historyManager.getHistory().get(1).equals(task2);\r\n\r\n        Assertions.assertTrue(isTrue);\r\n    }\r\n\r\n    @Test\r\n    void shouldRemoveIdFromBeginOfHistory() { // checking method remove(int id)\r\n        historyManager.add(task1); // +1\r\n        historyManager.add(epic); // +1\r\n        historyManager.add(task2); // +1\r\n        historyManager.remove(task1.getId()); // -1\r\n\r\n        boolean isTrue = historyManager.getHistory().get(0).equals(epic)\r\n                && historyManager.getHistory().get(1).equals(task2);\r\n\r\n        Assertions.assertTrue(isTrue);\r\n    }\r\n\r\n    @Test\r\n    void shouldRemoveIdFromEndOfHistory() { // checking method remove(int id)\r\n        historyManager.add(task1); // +1\r\n        historyManager.add(epic); // +1\r\n        historyManager.add(task2); // +1\r\n        historyManager.remove(task2.getId()); // -1\r\n\r\n        boolean isTrue = historyManager.getHistory().get(0).equals(task1)\r\n                && historyManager.getHistory().get(1).equals(epic);\r\n\r\n        Assertions.assertTrue(isTrue);\r\n    }\r\n\r\n    @Test\r\n    void shouldReturn0IdInHistoryAfterAdding0AndRemove1() { // checking method remove(int id)\r\n        historyManager.remove(task1.getId()); // 0 - 1 should be 0\r\n\r\n        int expectedSize = 0;\r\n        int actualSize = historyManager.getHistory().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n}\r\n",
      "info": {
        "size": 4937,
        "last_modified": "2025-09-14T16:23:16.3935673",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "com\\taskmanager\\managers\\HttpTaskManagerTest.java",
      "content": "package com.taskmanager.managers;\r\n\r\nimport com.taskmanager.api.KVServer;\r\nimport com.taskmanager.api.KVTaskClient;\r\nimport com.google.gson.Gson;\r\nimport com.google.gson.JsonElement;\r\nimport com.google.gson.JsonObject;\r\nimport com.google.gson.JsonParser;\r\nimport com.google.gson.reflect.TypeToken;\r\nimport org.junit.jupiter.api.*;\r\nimport com.taskmanager.tasks.*;\r\n\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport static com.taskmanager.managers.HttpTaskManager.kvTaskClient;\r\nimport static com.taskmanager.managers.HttpTaskManager.load;\r\n\r\n/**\r\n * Tests for {@link HttpTaskManager} that verify saving and loading of tasks, epics,\r\n * subtasks, and history to/from a {@link KVServer}.\r\n * <p>\r\n * This test class covers:\r\n * <ul>\r\n *     <li>Saving tasks, epics, and subtasks to KVServer</li>\r\n *     <li>Retrieving tasks, epics, and subtasks from KVServer</li>\r\n *     <li>Saving and retrieving history of accessed tasks</li>\r\n *     <li>Loading saved data correctly after restarting the HttpTaskManager</li>\r\n *     <li>Ensuring epics retain subtasks after saving/loading</li>\r\n * </ul>\r\n * <p>\r\n * Each test ensures data integrity by comparing fields of original and loaded tasks.\r\n * </p>\r\n */\r\nclass HttpTaskManagerTest extends TaskManagerTest<HttpTaskManager> {\r\n\r\n    private KVServer kvServer;\r\n    private final Gson gson = new Gson();\r\n\r\n    @BeforeEach\r\n    void setUp() throws IOException {\r\n        kvServer = new KVServer();\r\n        kvServer.start();\r\n\r\n        if (kvTaskClient != null) {\r\n            kvTaskClient = new KVTaskClient(KVServer.PORT);\r\n        }\r\n\r\n        taskManager = load(KVServer.PORT);\r\n        initTasks();\r\n    }\r\n\r\n    @AfterEach\r\n    void tearDown() {\r\n        taskManager.deleteAllTasksAllTypes();\r\n        taskManager.setNextId(1);\r\n        taskManager.setHistoryManager(new InMemoryHistoryManager());\r\n        kvServer.stop();\r\n    }\r\n\r\n    //-----------------------\r\n    // Checking method save()\r\n    //-----------------------\r\n\r\n    @Test\r\n    void shouldReturnSavedTaskFromKvServer() {\r\n        taskManager.createTask(task);\r\n\r\n        // Loading task from KVServer\r\n        String taskJsonElementString = kvTaskClient.load(\"ID_\" + task.getId());\r\n        JsonElement taskJsonElement = JsonParser.parseString(taskJsonElementString);\r\n        JsonObject taskJsonObjectString = taskJsonElement.getAsJsonObject();\r\n        Task taskFromKvServer = gson.fromJson(taskJsonObjectString, Task.class);\r\n\r\n        // Checking fields\r\n        String expectedName = task.getName();\r\n        String actualName = taskFromKvServer.getName();\r\n        String expectedDescription = task.getDescription();\r\n        String actualDescription = taskFromKvServer.getDescription();\r\n\r\n        Assertions.assertEquals(expectedName, actualName);\r\n        Assertions.assertEquals(expectedDescription, actualDescription);\r\n    }\r\n\r\n    @Test\r\n    void shouldReturnSavedSubtaskFromKvServer() {\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        // Loading task from KVServer\r\n        String subtaskJsonElementString = kvTaskClient.load(\"ID_\" + subtask.getId());\r\n        JsonElement subtaskJsonElement = JsonParser.parseString(subtaskJsonElementString);\r\n        JsonObject subtaskJsonObjectString = subtaskJsonElement.getAsJsonObject();\r\n        Subtask subtaskFromKvServer = gson.fromJson(subtaskJsonObjectString, Subtask.class);\r\n\r\n        // Checking fields\r\n        String expectedName = subtask.getName();\r\n        String actualName = subtaskFromKvServer.getName();\r\n        String expectedDescription = subtask.getDescription();\r\n        String actualDescription = subtaskFromKvServer.getDescription();\r\n        int expectedIdEpic = subtask.getIdEpic();\r\n        int actualIdEpic = subtaskFromKvServer.getIdEpic();\r\n\r\n        Assertions.assertEquals(expectedName, actualName);\r\n        Assertions.assertEquals(expectedDescription, actualDescription);\r\n        Assertions.assertEquals(expectedIdEpic, actualIdEpic);\r\n    }\r\n\r\n    @Test\r\n    void shouldReturnSavedEpicWith1SubtaskFromKvServer() {\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        // Loading task from KVServer\r\n        String epicJsonElementString = kvTaskClient.load(\"ID_\" + epic.getId());\r\n        JsonElement epicJsonElement = JsonParser.parseString(epicJsonElementString);\r\n        JsonObject epicJsonObjectString = epicJsonElement.getAsJsonObject();\r\n        Epic epicFromKvServer = gson.fromJson(epicJsonObjectString, Epic.class);\r\n\r\n        // Checking fields\r\n        String expectedName = epic.getName();\r\n        String actualName = epicFromKvServer.getName();\r\n        String expectedDescription = epic.getDescription();\r\n        String actualDescription = epicFromKvServer.getDescription();\r\n        int expectedSubtasksSizeByEpic = epic.subtasks.size();\r\n        int actualSubtasksSizeByEpic = epicFromKvServer.subtasks.size();\r\n\r\n        Assertions.assertEquals(expectedName, actualName);\r\n        Assertions.assertEquals(expectedDescription, actualDescription);\r\n        Assertions.assertEquals(expectedSubtasksSizeByEpic, actualSubtasksSizeByEpic);\r\n    }\r\n\r\n    @Test\r\n    void shouldReturnSavedHistoryFromKvServer() {\r\n        taskManager.createTask(task);\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        // Add history by get-method\r\n        taskManager.getSubtaskById(3); // History: 3\r\n        taskManager.getEpicById(2); // History: 3, 2\r\n        taskManager.getUsualTaskById(1); // History: 3, 2, 1\r\n\r\n        // Loading history from KVServer\r\n        String historyJsonElementString = kvTaskClient.load(\"History\");\r\n        List<Task> history = gson.fromJson(historyJsonElementString, new TypeToken<ArrayList<Task>>() {\r\n        }.getType());\r\n\r\n        // Checking size\r\n        int expectedHistorySize = taskManager.getHistoryManager().getHistory().size();\r\n        int actualHistorySize = history.size();\r\n\r\n        Assertions.assertEquals(expectedHistorySize, actualHistorySize);\r\n    }\r\n\r\n    //-----------------------\r\n    // Checking method load()\r\n    //-----------------------\r\n\r\n    @Test\r\n    void shouldLoadSavedTaskFromKvServerAfterRestartingHttpTaskManager() {\r\n        taskManager.createTask(task); // +1 task to tasks with saving\r\n        int expectedTasksSize = 1;\r\n        int actualTasksSize = taskManager.getTasks().size();\r\n        Assertions.assertEquals(expectedTasksSize, actualTasksSize);\r\n\r\n        InMemoryTaskManager.tasks.clear(); // deleting task direct from system without saving\r\n        expectedTasksSize = 0;\r\n        actualTasksSize = taskManager.getTasks().size();\r\n        Assertions.assertEquals(expectedTasksSize, actualTasksSize);\r\n\r\n        taskManager = load(KVServer.PORT); // loading saved data\r\n        expectedTasksSize = 1;\r\n        actualTasksSize = taskManager.getTasks().size();\r\n        Assertions.assertEquals(expectedTasksSize, actualTasksSize);\r\n    }\r\n\r\n    @Test\r\n    void shouldLoadSavedEpicFromKvServerAfterRestartingHttpEpicManager() {\r\n        taskManager.createEpic(epic); // +1 epic to epics with saving\r\n        int expectedEpicsSize = 1;\r\n        int actualEpicsSize = taskManager.getEpics().size();\r\n        Assertions.assertEquals(expectedEpicsSize, actualEpicsSize);\r\n\r\n        InMemoryTaskManager.epics.clear(); // deleting epic direct from system without saving\r\n        expectedEpicsSize = 0;\r\n        actualEpicsSize = taskManager.getEpics().size();\r\n        Assertions.assertEquals(expectedEpicsSize, actualEpicsSize);\r\n\r\n        taskManager = load(KVServer.PORT); // loading saved data\r\n        expectedEpicsSize = 1;\r\n        actualEpicsSize = taskManager.getEpics().size();\r\n        Assertions.assertEquals(expectedEpicsSize, actualEpicsSize);\r\n    }\r\n\r\n    @Test\r\n    void shouldLoadSavedSubtaskFromKvServerAfterRestartingHttpSubtaskManager() {\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask); // +1 subtask to subtasks with saving\r\n        int expectedSubtasksSize = 1;\r\n        int actualSubtasksSize = taskManager.getSubtasks().size();\r\n        Assertions.assertEquals(expectedSubtasksSize, actualSubtasksSize);\r\n\r\n        InMemoryTaskManager.subtasks.clear(); // deleting subtask direct from system without saving\r\n        expectedSubtasksSize = 0;\r\n        actualSubtasksSize = taskManager.getSubtasks().size();\r\n        Assertions.assertEquals(expectedSubtasksSize, actualSubtasksSize);\r\n\r\n        taskManager = load(KVServer.PORT); // loading saved data\r\n        expectedSubtasksSize = 1;\r\n        actualSubtasksSize = taskManager.getSubtasks().size();\r\n        Assertions.assertEquals(expectedSubtasksSize, actualSubtasksSize);\r\n    }\r\n\r\n    @Test\r\n    void shouldLoadSavedEpicsSubtaskFromKvServerAfterRestartingHttpSubtaskManager() {\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask); // +1 subtask to epics subtasks with saving\r\n\r\n        int expectedSubtasksByEpic = 1;\r\n        int actualSubtasksByEpic = taskManager.getEpicSubtasks(epic).size();\r\n        Assertions.assertEquals(expectedSubtasksByEpic, actualSubtasksByEpic);\r\n\r\n        taskManager = load(KVServer.PORT); // loading saved data\r\n\r\n        int expectedSubtasksByEpicAfterReloading = 1;\r\n        int actualSubtasksByEpicAfterReloading = taskManager.getEpicSubtasks(epic).size();\r\n        Assertions.assertEquals(expectedSubtasksByEpicAfterReloading, actualSubtasksByEpicAfterReloading);\r\n    }\r\n\r\n    @Test\r\n    void shouldLoadSavedHistoryFromKvServerAfterRestartingHttpSubtaskManager() {\r\n        taskManager.createTask(task);\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        // Add history by get-method\r\n        taskManager.getSubtaskById(3); // History: 3\r\n        taskManager.getEpicById(2); // History: 3, 2\r\n        taskManager.getUsualTaskById(1); // History: 3, 2, 1\r\n\r\n        int expectedHistorySize = 3;\r\n        int actualHistorySize = taskManager.getHistoryManager().getHistory().size();\r\n        Assertions.assertEquals(expectedHistorySize, actualHistorySize);\r\n\r\n        taskManager = load(KVServer.PORT); // loading saved data\r\n\r\n        int expectedHistorySizeAfterReloading = 3;\r\n        int actualHistorySizeAfterReloading = taskManager.getHistoryManager().getHistory().size();\r\n        Assertions.assertEquals(expectedHistorySizeAfterReloading, actualHistorySizeAfterReloading);\r\n    }\r\n\r\n    @Test\r\n    void shouldLoadSavedHistoryFromKvServerAfterRestartingHttpSubtaskManagerInCorrectQueue() {\r\n        taskManager.createTask(task);\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        // Add history by get-method\r\n        taskManager.getSubtaskById(3); // History: 3\r\n        taskManager.getEpicById(2); // History: 3, 2\r\n        taskManager.getUsualTaskById(1); // History: 3, 2, 1\r\n\r\n        int expectedFirstId = 3;\r\n        int expectedLastId = 1;\r\n        int actualFirstId = taskManager.getHistoryManager().getHistory().get(0).getId();\r\n        int actualLastId = taskManager.getHistoryManager().getHistory().get(2).getId();\r\n\r\n        Assertions.assertEquals(expectedFirstId, actualFirstId);\r\n        Assertions.assertEquals(expectedLastId, actualLastId);\r\n\r\n        taskManager = load(KVServer.PORT); // loading saved data\r\n\r\n        int expectedFirstIdAfterReloading = 3;\r\n        int expectedLastIdAfterReloading = 1;\r\n        int actualFirstIdAfterReloading = taskManager.getHistoryManager().getHistory().get(0).getId();\r\n        int actualLastIdAfterReloading = taskManager.getHistoryManager().getHistory().get(2).getId();\r\n\r\n        Assertions.assertEquals(expectedFirstIdAfterReloading, actualFirstIdAfterReloading);\r\n        Assertions.assertEquals(expectedLastIdAfterReloading, actualLastIdAfterReloading);\r\n    }\r\n\r\n}",
      "info": {
        "size": 12465,
        "last_modified": "2025-09-14T16:23:16.3995673",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "com\\taskmanager\\managers\\InMemoryHistoryManagerTest.java",
      "content": "package com.taskmanager.managers;\r\n\r\nimport org.junit.jupiter.api.BeforeEach;\r\n\r\n\r\n// TODO: add tests\r\nclass InMemoryHistoryManagerTest extends HistoryManagerTest<InMemoryHistoryManager> {\r\n\r\n    @BeforeEach\r\n    protected void beforeEach() {\r\n        historyManager = new InMemoryHistoryManager();\r\n        initTasks();\r\n    }\r\n\r\n}",
      "info": {
        "size": 332,
        "last_modified": "2025-09-14T16:23:16.4043064",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "com\\taskmanager\\managers\\InMemoryTaskManagerTest.java",
      "content": "package com.taskmanager.managers;\r\n\r\nimport org.junit.jupiter.api.AfterEach;\r\nimport org.junit.jupiter.api.BeforeEach;\r\n\r\n// TODO: add tests\r\nclass InMemoryTaskManagerTest extends TaskManagerTest<InMemoryTaskManager> {\r\n\r\n    @BeforeEach\r\n    protected void beforeEach() {\r\n        taskManager = new InMemoryTaskManager();\r\n        initTasks();\r\n    }\r\n\r\n    @AfterEach\r\n    protected void afterEach() {\r\n        taskManager.deleteAllTasksAllTypes();\r\n        InMemoryTaskManager.nextId = 1;\r\n        InMemoryTaskManager.historyManager = new InMemoryHistoryManager();\r\n    }\r\n\r\n}",
      "info": {
        "size": 579,
        "last_modified": "2025-09-14T16:23:16.4085013",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "com\\taskmanager\\managers\\TaskManagerTest.java",
      "content": "package com.taskmanager.managers;\r\n\r\nimport org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport com.taskmanager.tasks.*;\r\nimport com.taskmanager.tasks.TaskStatus;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.TreeSet;\r\n\r\n/**\r\n * Abstract test class for {@link TaskManager} implementations.\r\n * <p>\r\n * Provides generic tests for creating, updating, deleting, and retrieving\r\n * {@link Task}, {@link Epic}, and {@link Subtask} objects, as well as\r\n * verifying task history and task prioritization.\r\n * </p>\r\n * <p>\r\n * This class tests:\r\n * <ul>\r\n *     <li>Creating tasks, epics, and subtasks</li>\r\n *     <li>Updating tasks, epics, and subtasks (name, description, status)</li>\r\n *     <li>Deleting tasks, epics, subtasks individually or all at once</li>\r\n *     <li>Validating history manager behavior</li>\r\n *     <li>Task ID generation and exception handling for invalid IDs</li>\r\n *     <li>Priority-based task sorting and validation of date/time constraints</li>\r\n * </ul>\r\n * </p>\r\n * <p>\r\n * Concrete subclasses should provide a specific {@link TaskManager} implementation\r\n * to be tested.\r\n * </p>\r\n */\r\nabstract class TaskManagerTest<T extends TaskManager> { // Testing methods of interface TaskManager\r\n\r\n    protected T taskManager;\r\n    protected Task task;\r\n    protected Epic epic;\r\n    protected Subtask subtask;\r\n\r\n    protected void initTasks() {\r\n        task = new Task(\"Task\", \"DescrT\", TaskStatus.NEW);\r\n        epic = new Epic(\"Epic1\", \"DescrEp1\");\r\n        // For creating tests: subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnHistorySize1FromHistoryManager() { // checking method getHistoryManager()\r\n        taskManager.createTask(task);\r\n\r\n        taskManager.getUsualTaskById(1);\r\n        List<Task> history = taskManager.getHistoryManager().getHistory();\r\n\r\n        int expectedHistorySize = 1;\r\n        int actualHistorySize = history.size();\r\n\r\n        Assertions.assertEquals(expectedHistorySize, actualHistorySize);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnHistorySize0FromHistoryManager() { // checking method getHistoryManager()\r\n        List<Task> history = taskManager.getHistoryManager().getHistory();\r\n\r\n        int expectedHistorySize = 0;\r\n        int actualHistorySize = history.size();\r\n\r\n        Assertions.assertEquals(expectedHistorySize, actualHistorySize);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldIncreaseSizeFromTasksListTo1AfterCreatingTask() { // checking method createTask(Task task)\r\n        taskManager.createTask(task);\r\n\r\n        int expectedSize = 1;\r\n        int actualSize = taskManager.getTasks().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldIncreaseSizeFromTasksListTo2AfterCreatingTask() { // checking method createTask(Task task)\r\n        taskManager.createTask(task);\r\n        taskManager.createTask(task);\r\n\r\n        int expectedSize = 2;\r\n        int actualSize = taskManager.getTasks().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldIncreaseSizeFromEpicsListTo1AfterCreatingEpic() { // checking method createEpic(Epic epic)\r\n        taskManager.createEpic(epic);\r\n\r\n        int expectedSize = 1;\r\n        int actualSize = taskManager.getEpics().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldIncreaseSizeFromEpicsListTo2AfterCreatingEpic() { // checking method createEpic(Epic epic)\r\n        taskManager.createEpic(epic);\r\n        taskManager.createEpic(epic);\r\n\r\n        int expectedSize = 2;\r\n        int actualSize = taskManager.getEpics().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldIncreaseSizeFromSubtasksListTo1AfterCreatingSubtask() { //checking method createSubtask(Sb sb)\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        int expectedSize = 1;\r\n        int actualSize = taskManager.getSubtasks().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n\r\n    @Test\r\n    protected void shouldIncreaseSizeFromSubtasksListTo2AfterCreatingSubtask() { //checking method createSubtask(Sb sb)\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n        taskManager.createSubtask(subtask);\r\n\r\n        int expectedSize = 2;\r\n        int actualSize = taskManager.getSubtasks().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldThrowExceptionByCreatingSubtaskWithIncorrectEpicId() { // checking createSubtask(Sb sb, int id)\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\",\r\n                TaskStatus.NEW, 33);\r\n\r\n        final IllegalArgumentException exception = Assertions.assertThrows(\r\n                IllegalArgumentException.class,\r\n                () -> taskManager.createSubtask(subtask)\r\n        );\r\n\r\n        Assertions.assertEquals(\"Epic with such ID not exist.\", exception.getMessage());\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnNextIdNumber2() { //checking method generateId()\r\n        int initialIdInSystemIs = 1;\r\n        int expectedIdNumber = initialIdInSystemIs + 1;\r\n\r\n        taskManager.generateId(); // +1\r\n        int actualIdNumber = taskManager.generateId(); // cause 'return nextId++' (please see method generateId())\r\n\r\n        Assertions.assertEquals(expectedIdNumber, actualIdNumber);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnNextIdNumber3() { //checking method generateId()\r\n        int initialIdInSystemIs = 1;\r\n        int expectedIdNumber = initialIdInSystemIs + 2;\r\n\r\n        taskManager.generateId(); // +1\r\n        taskManager.generateId(); // +1\r\n\r\n        int actualIdNumber = taskManager.generateId(); // cause 'return nextId++' (please see method generateId())\r\n\r\n        Assertions.assertEquals(expectedIdNumber, actualIdNumber);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCreatedSubtaskFromEpicSubtasks() { // checking method getEpicSubtasks(Epic epic)\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        ArrayList<Subtask> subtasks = taskManager.getEpicSubtasks(epic);\r\n\r\n        Subtask expectedSubtask = subtask;\r\n        Subtask actualSubtask = subtasks.get(0);\r\n\r\n        Assertions.assertEquals(expectedSubtask, actualSubtask);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturn0SubtaskFromEpicSubtasks() { // checking method getEpicSubtasks(Epic epic)\r\n        taskManager.createEpic(epic);\r\n        ArrayList<Subtask> subtasks = taskManager.getEpicSubtasks(epic);\r\n\r\n        int expectedSize = 0;\r\n        int actualSize = subtasks.size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCorrectedNameOfChosenTask() { // checking method updateUsualTask(Task task, int id)\r\n        taskManager.createTask(task);\r\n\r\n        String expectedName = \"NewTaskText\";\r\n        Task updatedTaskData = new Task(\"NewTaskText\", \"DescrT\", TaskStatus.NEW);\r\n\r\n        taskManager.updateUsualTask(updatedTaskData, task.getId());\r\n        String actualName = taskManager.getTasks().get(task.getId()).getName();\r\n\r\n        Assertions.assertEquals(expectedName, actualName);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCorrectedDescriptionOfChosenTask() { //checking method updateUsualTask(Task task, int id)\r\n        taskManager.createTask(task);\r\n\r\n        String expectedDescription = \"NewTaskDescrT\";\r\n        Task updatedTaskData = new Task(\"Task\", \"NewTaskDescrT\", TaskStatus.NEW);\r\n\r\n        taskManager.updateUsualTask(updatedTaskData, task.getId());\r\n        String actualDescription = taskManager.getTasks().get(task.getId()).getDescription();\r\n\r\n        Assertions.assertEquals(expectedDescription, actualDescription);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCorrectedStatusOfChosenTask() { //checking method updateUsualTask(Task task, int id)\r\n        taskManager.createTask(task);\r\n\r\n        TaskStatus expectedStatus = TaskStatus.DONE;\r\n        Task updatedTaskData = new Task(\"Task\", \"DescrT\", TaskStatus.DONE);\r\n\r\n        taskManager.updateUsualTask(updatedTaskData, task.getId());\r\n        TaskStatus actualStatus = taskManager.getTasks().get(task.getId()).getStatus();\r\n\r\n        Assertions.assertEquals(expectedStatus, actualStatus);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldNotUpdateTaskWithWrongGivenIdAndNotCreateNew() { //checking method updateUsualTask(T t, int id)\r\n        taskManager.createTask(task); // ID = 1\r\n\r\n        Task updatedTaskData = new Task(\"Task123\", \"DescrT123\");\r\n\r\n        final IllegalArgumentException exception = Assertions.assertThrows(\r\n                IllegalArgumentException.class,\r\n                () -> taskManager.updateUsualTask(updatedTaskData, 10)\r\n        );\r\n\r\n        Assertions.assertEquals(\"Usual Task with such ID not exist.\", exception.getMessage());\r\n\r\n        String expectedName = \"Task\";\r\n        String actualName = taskManager.getTasks().get(1).getName();\r\n\r\n        Assertions.assertEquals(expectedName, actualName);\r\n\r\n        int expectedSize = 1;\r\n        int actualSize = taskManager.getTasks().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCorrectedNameOfChosenEpic() { // checking method updateEpic(Epic epic, int id)\r\n        taskManager.createEpic(epic);\r\n\r\n        String expectedName = \"NewEpicText\";\r\n        Epic updatedEpicData = new Epic(\"NewEpicText\", \"DescrEp\");\r\n\r\n        taskManager.updateEpic(updatedEpicData, epic.getId());\r\n        String actualName = taskManager.getEpics().get(epic.getId()).getName();\r\n\r\n        Assertions.assertEquals(expectedName, actualName);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCorrectedDescriptionOfChosenEpic() { // checking method updateEpic(Epic epic, int id)\r\n        taskManager.createEpic(epic);\r\n\r\n        String expectedDescription = \"NewEpicDescrEp\";\r\n        Epic updatedEpicData = new Epic(\"Epic1\", \"NewEpicDescrEp\");\r\n\r\n        taskManager.updateEpic(updatedEpicData, epic.getId());\r\n        String actualDescription = taskManager.getEpics().get(epic.getId()).getDescription();\r\n\r\n        Assertions.assertEquals(expectedDescription, actualDescription);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnSubtasksByUpdatingEpic() {\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n        Subtask subtask1 = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n\r\n        int expectedSizeOfSubtasks = 2;\r\n        Epic updatedEpicData = new Epic(\"Epic1\", \"NewEpicDescrEp\");\r\n\r\n        taskManager.updateEpic(updatedEpicData, epic.getId());\r\n        int actualSizeOfSubtasks = taskManager.getEpics().get(epic.getId()).subtasks.size();\r\n\r\n        Assertions.assertEquals(expectedSizeOfSubtasks, actualSizeOfSubtasks);\r\n\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCorrectedNameOfChosenSubtask() { //checking method updateSubtask(Subtask subtask, int id)\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        String expectedName = \"NewSubtaskText\";\r\n        Subtask updatedSTData = new Subtask(\"NewSubtaskText\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n\r\n        taskManager.updateSubtask(updatedSTData, subtask.getId());\r\n        String actualName = taskManager.getSubtasks().get(subtask.getId()).getName();\r\n\r\n        Assertions.assertEquals(expectedName, actualName);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCorrectedDescriptionOfChosenSubtask() { //checking method updateSubtask(Sb sb, int id)\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        String expectedDescription = \"NewSDescrSt2\";\r\n        Subtask updatedSTData = new Subtask(\"Subtask2\", \"NewSDescrSt2\", TaskStatus.NEW, epic.getId());\r\n\r\n        taskManager.updateSubtask(updatedSTData, subtask.getId());\r\n        String actualDescription = taskManager.getSubtasks().get(subtask.getId()).getDescription();\r\n\r\n        Assertions.assertEquals(expectedDescription, actualDescription);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCorrectedStatusOfChosenSubtask() { //checking method updateSubtask(Sb sb, int id)\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        TaskStatus expectedStatus = TaskStatus.DONE;\r\n        Subtask updatedSTData = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.DONE, epic.getId());\r\n\r\n        taskManager.updateSubtask(updatedSTData, subtask.getId());\r\n        TaskStatus actualStatus = taskManager.getSubtasks().get(subtask.getId()).getStatus();\r\n\r\n        Assertions.assertEquals(expectedStatus, actualStatus);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldThrowExceptionByUpdatingSubtaskWithIncorrectEpicId() { //checking updateSubtask(Sb sb, int id)\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n        Subtask updatedSTData = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.DONE, 33);\r\n\r\n        final IllegalArgumentException exception = Assertions.assertThrows(\r\n                IllegalArgumentException.class,\r\n                () -> taskManager.updateSubtask(updatedSTData, subtask.getId())\r\n        );\r\n\r\n        Assertions.assertEquals(\"Epic with such ID not exist.\", exception.getMessage());\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnRightIdOfTask() { // checking method getUsualTaskById(int id)\r\n        taskManager.createTask(task);\r\n\r\n        int expectedId = 1;\r\n        int actualId = taskManager.getTasks().get(task.getId()).getId();\r\n\r\n        Assertions.assertEquals(expectedId, actualId);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldThrowExceptionByInputWrongTaskId() { // checking method getUsualTaskById(int id)\r\n        taskManager.createTask(task); // Id = 1\r\n\r\n        final IllegalArgumentException exception = Assertions.assertThrows(\r\n                IllegalArgumentException.class,\r\n                () -> taskManager.getUsualTaskById(33)\r\n        );\r\n\r\n        Assertions.assertEquals(\"Usual Task with such ID not exist.\", exception.getMessage());\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnRightIdOfEpic() { // checking method getEpicById(int id)\r\n        taskManager.createEpic(epic);\r\n\r\n        int expectedId = 1;\r\n        int actualId = taskManager.getEpics().get(epic.getId()).getId();\r\n\r\n        Assertions.assertEquals(expectedId, actualId);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldThrowExceptionByInputWrongEpicId() { // checking method getEpicById(int id)\r\n        taskManager.createEpic(epic); // Id = 1\r\n\r\n        final IllegalArgumentException exception = Assertions.assertThrows(\r\n                IllegalArgumentException.class,\r\n                () -> taskManager.getEpicById(33)\r\n        );\r\n\r\n        Assertions.assertEquals(\"Epic with such ID not exist.\", exception.getMessage());\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnRightIdOfSubtask() { // checking method getSubtaskById(int id)\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        int expectedId = 2; // 1st is Epic\r\n        int actualId = taskManager.getSubtasks().get(subtask.getId()).getId();\r\n\r\n        Assertions.assertEquals(expectedId, actualId);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldThrowExceptionByInputWrongSubtaskId() { // checking method getSubtaskById(int id)\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask); // Id = 1\r\n\r\n        final IllegalArgumentException exception = Assertions.assertThrows(\r\n                IllegalArgumentException.class,\r\n                () -> taskManager.getSubtaskById(33)\r\n        );\r\n\r\n        Assertions.assertEquals(\"Subtask with such ID not exist.\", exception.getMessage());\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCreatedTaskFromTasks() { // checking method getTasks()\r\n        taskManager.createTask(task);\r\n        HashMap<Integer, Task> tasks = taskManager.getTasks();\r\n\r\n        Task expectedTask = task;\r\n        Task actualTask = tasks.get(1);\r\n\r\n        Assertions.assertEquals(expectedTask, actualTask);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCreatedEpicFromEpics() { // checking method getEpics()\r\n        taskManager.createEpic(epic);\r\n        HashMap<Integer, Epic> epics = taskManager.getEpics();\r\n\r\n        Task expectedEpic = epic;\r\n        Task actualEpic = epics.get(1);\r\n\r\n        Assertions.assertEquals(expectedEpic, actualEpic);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnCreatedSubtaskFromSubtasks() { // checking method getSubtasks()\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask);\r\n\r\n        HashMap<Integer, Subtask> subtasks = taskManager.getSubtasks();\r\n\r\n        Task expectedSubtask = subtask;\r\n        Task actualSubtask = subtasks.get(2);\r\n\r\n        Assertions.assertEquals(expectedSubtask, actualSubtask);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnSortedSetOfTasksByPriority() { // checking method getPrioritizedTasks();\r\n        taskManager.createTask(task); // +1 Task without DateTimeParameters\r\n\r\n        Task taskP = new Task(\"Task\", \"DescrT\", TaskStatus.NEW, \"02.06.2024, 09:30\", 60L);\r\n        taskManager.createTask(taskP); // +1 Task with DateTimeParameters\r\n\r\n        taskManager.createEpic(epic); // +0 Epic (will not get to prioritizedTasks list)\r\n\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, \"02.06.2024, 12:30\", 120L, epic.getId());\r\n        taskManager.createSubtask(subtask); // +1 Subtask with DateTimeParameters\r\n\r\n        Subtask subtaskP = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, \"01.05.2024, 09:30\", 80L, epic.getId());\r\n        taskManager.createSubtask(subtaskP); // +1 Subtask with DateTimeParameters\r\n\r\n        TreeSet<Task> prioritizedTasks = taskManager.getPrioritizedTasks();\r\n\r\n        boolean priorityIsTrue = prioritizedTasks.first().equals(subtaskP) && prioritizedTasks.last().equals(task)\r\n                && prioritizedTasks.size() == 4;\r\n\r\n        Assertions.assertTrue(priorityIsTrue);\r\n\r\n    }\r\n\r\n    @Test\r\n    protected void shouldNotCreateTasksWithWrongDateTimeValidation() { // checking method isValidDateTime();\r\n        taskManager.createTask(task); // +1 Task without DateTimeParameters\r\n\r\n        Task taskP = new Task(\"Task\", \"DescrT\", TaskStatus.NEW, \"02.06.2024, 09:30\", 60L);\r\n        taskManager.createTask(taskP); // +1 Task with right DateTimeParameters\r\n\r\n        taskManager.createEpic(epic); // +1 Epic\r\n\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, \"06.06.2024, 12:30\", 120L, epic.getId());\r\n        taskManager.createSubtask(subtask); // +1 Subtask with right DateTimeParameters\r\n\r\n        Task taskWrong = new Task(\"Task\", \"DescrT\", TaskStatus.NEW, \"10.06.2024, 09:30\", -100L);\r\n        taskManager.createTask(taskWrong); // +1 Task with wrong Duration (-100 => 0)\r\n\r\n        Subtask subtaskP = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, \"06.06.2024, 13:30\", 80L, epic.getId());\r\n        taskManager.createSubtask(subtaskP); // +0 Subtask with wrong startTime\r\n\r\n        Subtask subtaskWrong = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, \"06.06.2024, 11:30\", 180L,\r\n                epic.getId());\r\n        taskManager.createSubtask(subtaskWrong); // +0 Subtask with wrong endTime\r\n\r\n        int expectedSize = 5;\r\n        int actualSize = taskManager.getTasks().size() + taskManager.getSubtasks().size()\r\n                + taskManager.getEpics().size();\r\n\r\n        Assertions.assertEquals(expectedSize, actualSize);\r\n\r\n    }\r\n\r\n\r\n    @Test\r\n    protected void shouldReturnEmptyListAfterDeleting1Task() { // checking method deleteTaskById(int id)\r\n        taskManager.createTask(task); // +1 Task\r\n        taskManager.deleteTaskById(task.getId()); // -1 Task\r\n\r\n        HashMap<Integer, Task> tasks = taskManager.getTasks();\r\n\r\n        boolean listIsEmpty = tasks.isEmpty();\r\n\r\n        Assertions.assertTrue(listIsEmpty);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldThrowExceptionByDeletingWrongTaskId() { // checking method deleteTaskById(int id)\r\n        taskManager.createTask(task); // Id = 1\r\n\r\n        final IllegalArgumentException exception = Assertions.assertThrows(\r\n                IllegalArgumentException.class,\r\n                () -> taskManager.deleteTaskById(33)\r\n        );\r\n\r\n        Assertions.assertEquals(\"Task with such ID not exist.\", exception.getMessage());\r\n\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnEmptyListAfterDeleting1Epic() { // checking method deleteEpicById(int id)\r\n        taskManager.createEpic(epic); // +1 Epic\r\n        taskManager.deleteEpicById(epic.getId()); // -1 Epic\r\n\r\n        HashMap<Integer, Epic> epics = taskManager.getEpics();\r\n\r\n        boolean listIsEmpty = epics.isEmpty();\r\n\r\n        Assertions.assertTrue(listIsEmpty);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldThrowExceptionByDeletingWrongEpicId() { // checking method deleteEpicById(int id)\r\n        taskManager.createEpic(epic); // Id = 1\r\n\r\n        final IllegalArgumentException exception = Assertions.assertThrows(\r\n                IllegalArgumentException.class,\r\n                () -> taskManager.deleteEpicById(33)\r\n        );\r\n\r\n        Assertions.assertEquals(\"Epic with such ID not exist.\", exception.getMessage());\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnEmptyListAfterDeleting1Subtask() { // checking method deleteSubtaskById(int id)\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask); // +1 Subtask\r\n        taskManager.deleteSubtaskById(subtask.getId()); // -1 Subtask\r\n\r\n        HashMap<Integer, Subtask> subtasks = taskManager.getSubtasks();\r\n\r\n        boolean listIsEmpty = subtasks.isEmpty();\r\n\r\n        Assertions.assertTrue(listIsEmpty);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldThrowExceptionByDeletingWrongSubtaskId() { // checking method deleteSubtaskById(int id)\r\n        taskManager.createEpic(epic); // Id = 1\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask); // Id = 2\r\n\r\n        final IllegalArgumentException exception = Assertions.assertThrows(\r\n                IllegalArgumentException.class,\r\n                () -> taskManager.deleteSubtaskById(33)\r\n        );\r\n\r\n        Assertions.assertEquals(\"Subtask with such ID not exist.\", exception.getMessage());\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnEmptyListAfterDeletingAllTasks() { // checking method deleteAllUsualTasks()\r\n        taskManager.createTask(task); // +1 Task\r\n        taskManager.createTask(task); // +1 Task\r\n        taskManager.deleteAllUsualTasks(); // -2 Tasks\r\n\r\n        HashMap<Integer, Task> tasks = taskManager.getTasks();\r\n\r\n        boolean listIsEmpty = tasks.isEmpty();\r\n\r\n        Assertions.assertTrue(listIsEmpty);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnEmptyListAfterDeletingAllEpics() { // checking method deleteAllEpics()\r\n        taskManager.createEpic(epic); // +1 Epic\r\n        taskManager.createEpic(epic); // +1 Epic\r\n        taskManager.deleteAllEpics(); // -2 Epics\r\n\r\n        HashMap<Integer, Epic> epics = taskManager.getEpics();\r\n\r\n        boolean listIsEmpty = epics.isEmpty();\r\n\r\n        Assertions.assertTrue(listIsEmpty);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnEmptyListAfterDeletingAllSubtasks() { // checking method deleteAllSubtasks()\r\n        taskManager.createEpic(epic);\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask); // +1 Subtask\r\n        taskManager.createSubtask(subtask); // +1 Subtask\r\n        taskManager.deleteAllSubtasks(); // -2 Subtasks\r\n\r\n        HashMap<Integer, Subtask> subtasks = taskManager.getSubtasks();\r\n\r\n        boolean listIsEmpty = subtasks.isEmpty();\r\n\r\n        Assertions.assertTrue(listIsEmpty);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnEmptyListAfterDeletingAllTasksAllTypes() { // checking method deleteAllTasksAllTypes()\r\n        taskManager.createTask(task); // +1 Task\r\n        taskManager.createEpic(epic); // +1 Epic\r\n        subtask = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask); // +1 Subtask\r\n        taskManager.deleteAllTasksAllTypes(); // -1 Task -1 Epic -1 Subtask\r\n\r\n        HashMap<Integer, Task> tasks = taskManager.getTasks();\r\n        HashMap<Integer, Epic> epics = taskManager.getEpics();\r\n        HashMap<Integer, Subtask> subtasks = taskManager.getSubtasks();\r\n\r\n        boolean listIsEmpty = tasks.isEmpty() && epics.isEmpty() && subtasks.isEmpty();\r\n\r\n        Assertions.assertTrue(listIsEmpty);\r\n    }\r\n}\r\n",
      "info": {
        "size": 26002,
        "last_modified": "2025-09-14T16:23:16.4129091",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "com\\taskmanager\\tasks\\EpicTest.java",
      "content": "package com.taskmanager.tasks;\r\n\r\nimport com.taskmanager.main_manager.Managers;\r\nimport com.taskmanager.managers.InMemoryHistoryManager;\r\nimport com.taskmanager.managers.TaskManager;\r\nimport org.junit.jupiter.api.*;\r\n\r\n/**\r\n * Unit tests for {@link Epic} behavior.\r\n * <p>\r\n * Tests include:\r\n * <ul>\r\n *   <li>Calculation of Epic status based on its subtasks.</li>\r\n *   <li>Determining start time, end time, and duration from subtasks.</li>\r\n *   <li>Handling of subtasks with null or invalid time/duration values.</li>\r\n * </ul>\r\n * </p>\r\n * <p>\r\n * Uses {@link TaskManager} to manage creation of subtasks for testing purposes.\r\n * </p>\r\n */\r\nclass EpicTest {\r\n\r\n    private TaskManager taskManager;\r\n    private Epic epic;\r\n\r\n    @BeforeEach\r\n    protected void beforeEach() {\r\n        taskManager = Managers.getDefaultWithoutSaving();\r\n        epic = new Epic(\"Epic\", \"DescrEp\"); // Create 1x Epic without Subtasks\r\n        taskManager.createEpic(epic);\r\n    }\r\n\r\n    @AfterEach\r\n    protected void afterEach() {\r\n        taskManager.deleteAllTasksAllTypes();\r\n        taskManager.setNextId(1);\r\n        taskManager.setHistoryManager(new InMemoryHistoryManager());\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnStatusNewByCreatedEpicWithoutSubtasks() {\r\n        // Expected and actual Status\r\n        TaskStatus expectedStatus = TaskStatus.NEW;\r\n        TaskStatus actualStatus = epic.getStatus();\r\n\r\n        // Assertion\r\n        Assertions.assertEquals(expectedStatus, actualStatus);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnStatusNewByCreatedEpicWithSubtasksWithStatusNewEach() {\r\n        // For created Epic create 2x Subtasks with status NEW each\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n\r\n        // Expected and actual Status\r\n        TaskStatus expectedStatus = TaskStatus.NEW;\r\n        TaskStatus actualStatus = epic.getStatus();\r\n\r\n        // Assertion\r\n        Assertions.assertEquals(expectedStatus, actualStatus);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnStatusDoneByCreatedEpicWithSubtasksWithStatusDoneEach() {\r\n        // For created Epic create 2x Subtasks with status DONE each\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", TaskStatus.DONE, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.DONE, epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n\r\n        // Expected and actual Status\r\n        TaskStatus expectedStatus = TaskStatus.DONE;\r\n        TaskStatus actualStatus = epic.getStatus();\r\n\r\n        // Assertion\r\n        Assertions.assertEquals(expectedStatus, actualStatus);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnStatusInProgressByCreatedEpicWithSubtasksWithStatusDoneAndNew() {\r\n        // For created Epic create 2x Subtasks with status DONE and NEW\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", TaskStatus.DONE, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.NEW, epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n\r\n        // Expected and actual Status\r\n        TaskStatus expectedStatus = TaskStatus.IN_PROGRESS;\r\n        TaskStatus actualStatus = epic.getStatus();\r\n\r\n        // Assertion\r\n        Assertions.assertEquals(expectedStatus, actualStatus);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnStatusInProgressByCreatedEpicWithSubtasksWithStatusInProgressEach() {\r\n        // For created Epic create 2x Subtasks with status DONE and NEW\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", TaskStatus.IN_PROGRESS, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", TaskStatus.IN_PROGRESS, epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n\r\n        // Expected and actual Status\r\n        TaskStatus expectedStatus = TaskStatus.IN_PROGRESS;\r\n        TaskStatus actualStatus = epic.getStatus();\r\n\r\n        // Assertion\r\n        Assertions.assertEquals(expectedStatus, actualStatus);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnStartTimeByEpicAsBySubtask() { // checking method checkStartTimeEpic()\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\",\r\n                \"01.06.2024, 09:30\", 60L, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        epic.checkStartTimeEpic();\r\n\r\n        String expectedStartTime = \"01.06.2024, 09:30\";\r\n        String actualStartTime;\r\n\r\n        if (epic.getStartTime().isPresent()) {\r\n            actualStartTime = epic.getStartTime().get().format(Task.dateTimeFormatter);\r\n        } else {\r\n            actualStartTime = null;\r\n        }\r\n\r\n        Assertions.assertEquals(expectedStartTime, actualStartTime);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnEarliestStartTimeByEpic() { // checking method checkStartTimeEpic()\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", \"02.06.2024, 13:30\", 60L, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", \"02.06.2024, 10:30\", 80L, epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n        Subtask subtask3 = new Subtask(\"Subtask2\", \"DescrSt2\", \"01.06.2024, 09:30\", 120L, epic.getId());\r\n        taskManager.createSubtask(subtask3);\r\n        epic.checkStartTimeEpic();\r\n\r\n        String expectedStartTime = \"01.06.2024, 09:30\";\r\n        String actualStartTime;\r\n\r\n        if (epic.getStartTime().isPresent()) {\r\n            actualStartTime = epic.getStartTime().get().format(Task.dateTimeFormatter);\r\n        } else {\r\n            actualStartTime = null;\r\n        }\r\n\r\n        Assertions.assertEquals(expectedStartTime, actualStartTime);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnStartTimeByEpicWithSubtaskWithoutDateTimeParameters() { // checking checkStartTimeEpic()\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", \"01.06.2024, 09:30\", 60L, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n        epic.checkStartTimeEpic();\r\n\r\n        String expectedStartTime = \"01.06.2024, 09:30\";\r\n        String actualStartTime;\r\n\r\n        if (epic.getStartTime().isPresent()) {\r\n            actualStartTime = epic.getStartTime().get().format(Task.dateTimeFormatter);\r\n        } else {\r\n            actualStartTime = null;\r\n        }\r\n\r\n        Assertions.assertEquals(expectedStartTime, actualStartTime);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnStartTimeNullByEpicWithSubtaskWithNullDateTimeParameters() { // checkStartTimeEpic()\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", null, 60L, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n        epic.checkStartTimeEpic();\r\n\r\n        String expectedStartTime = null;\r\n        String actualStartTime;\r\n\r\n        if (epic.getStartTime().isPresent()) {\r\n            actualStartTime = epic.getStartTime().get().format(Task.dateTimeFormatter);\r\n        } else {\r\n            actualStartTime = null;\r\n        }\r\n\r\n        Assertions.assertEquals(expectedStartTime, actualStartTime);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnDurationByEpicWithSubtasks() { // checking method checkDurationEpic()\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", \"02.06.2024, 13:30\", 60L, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", \"02.06.2024, 10:30\", 80L, epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n        Subtask subtask3 = new Subtask(\"Subtask2\", \"DescrSt2\", \"01.06.2024, 09:30\", 120L, epic.getId());\r\n        taskManager.createSubtask(subtask3);\r\n        epic.checkDurationEpic();\r\n\r\n        long expectedDuration = 260L; // 60 + 80 + 120\r\n        long actualDuration;\r\n\r\n        if (epic.getDuration().isPresent()) {\r\n            actualDuration = epic.getDuration().get().toMinutes();\r\n        } else {\r\n            actualDuration = -1;\r\n        }\r\n\r\n        Assertions.assertEquals(expectedDuration, actualDuration);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnDuration0ByEpicWithSubtaskWithNegativeDuration() { // checking method checkDurationEpic()\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", \"02.06.2024, 13:30\", -60, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        epic.checkDurationEpic();\r\n\r\n        long expectedDuration = 0L;\r\n        long actualDuration;\r\n\r\n        if (epic.getDuration().isPresent()) {\r\n            actualDuration = epic.getDuration().get().toMinutes();\r\n        } else {\r\n            actualDuration = -1L;\r\n        }\r\n\r\n        Assertions.assertEquals(expectedDuration, actualDuration);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnDurationByEpicWithSubtaskWithNegativeDuratioAndNormalDuration() { // checkDurationEpic()\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", \"02.06.2024, 13:30\", -60L, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", \"02.06.2024, 10:30\", 80L, epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n        epic.checkDurationEpic();\r\n\r\n        long expectedDuration = 80L; // (-60 => 0) + 80\r\n        long actualDuration;\r\n\r\n        if (epic.getDuration().isPresent()) {\r\n            actualDuration = epic.getDuration().get().toMinutes();\r\n        } else {\r\n            actualDuration = -1L;\r\n        }\r\n\r\n        Assertions.assertEquals(expectedDuration, actualDuration);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnEndTimeByEpicAsBySubtask() { // checking method checkEndTimeEpic()\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", \"01.06.2024, 09:30\", 60L, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        epic.checkEndTimeEpic();\r\n\r\n        String expectedEndTime = \"01.06.2024, 10:30\";\r\n        String actualEndTime;\r\n\r\n        if (epic.getEndTime().isPresent()) {\r\n            actualEndTime = epic.getEndTime().get().format(Task.dateTimeFormatter);\r\n        } else {\r\n            actualEndTime = null;\r\n        }\r\n\r\n        Assertions.assertEquals(expectedEndTime, actualEndTime);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnLatestEndTimeByEpic() { // checking method checkEndTimeEpic()\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", \"01.06.2024, 09:30\", 60L, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", \"02.06.2024, 10:30\", 80L, epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n        Subtask subtask3 = new Subtask(\"Subtask2\", \"DescrSt2\", \"02.06.2024, 13:30\", 120L, epic.getId());\r\n        taskManager.createSubtask(subtask3);\r\n        epic.checkEndTimeEpic();\r\n\r\n        String expectedEndTime = \"02.06.2024, 15:30\";\r\n        String actualSEndTime;\r\n\r\n        if (epic.getEndTime().isPresent()) {\r\n            actualSEndTime = epic.getEndTime().get().format(Task.dateTimeFormatter);\r\n        } else {\r\n            actualSEndTime = null;\r\n        }\r\n\r\n        Assertions.assertEquals(expectedEndTime, actualSEndTime);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnEndTimeByEpicWithSubtaskWithoutDateTimeParameters() { // checking checkEndTimeEpic()\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", \"01.06.2024, 09:30\", 60L, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n        epic.checkEndTimeEpic();\r\n\r\n        String expectedEndTime = \"01.06.2024, 10:30\";\r\n        String actualSEndTime;\r\n\r\n        if (epic.getEndTime().isPresent()) {\r\n            actualSEndTime = epic.getEndTime().get().format(Task.dateTimeFormatter);\r\n        } else {\r\n            actualSEndTime = null;\r\n        }\r\n\r\n        Assertions.assertEquals(expectedEndTime, actualSEndTime);\r\n    }\r\n\r\n    @Test\r\n    protected void shouldReturnEndTimeNullByEpicWithSubtaskWithNullDateTimeParameters() { // checking checkEndTimeEpic()\r\n        Subtask subtask1 = new Subtask(\"Subtask1\", \"DescrSt1\", null, 60L, epic.getId());\r\n        taskManager.createSubtask(subtask1);\r\n        Subtask subtask2 = new Subtask(\"Subtask2\", \"DescrSt2\", epic.getId());\r\n        taskManager.createSubtask(subtask2);\r\n        epic.checkEndTimeEpic();\r\n\r\n        String expectedEndTime = null;\r\n        String actualEndTime;\r\n\r\n        if (epic.getEndTime().isPresent()) {\r\n            actualEndTime = epic.getEndTime().get().format(Task.dateTimeFormatter);\r\n        } else {\r\n            actualEndTime = null;\r\n        }\r\n\r\n        Assertions.assertEquals(expectedEndTime, actualEndTime);\r\n    }\r\n\r\n}",
      "info": {
        "size": 13251,
        "last_modified": "2025-09-14T16:23:16.4200197",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    }
  ]
}